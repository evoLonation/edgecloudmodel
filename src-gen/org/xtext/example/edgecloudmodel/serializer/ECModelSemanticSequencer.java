/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.edgecloudmodel.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.edgecloudmodel.eCModel.ActivityFinal;
import org.xtext.example.edgecloudmodel.eCModel.Actor;
import org.xtext.example.edgecloudmodel.eCModel.ArgumentsCS;
import org.xtext.example.edgecloudmodel.eCModel.AtomicExpression;
import org.xtext.example.edgecloudmodel.eCModel.Attribute;
import org.xtext.example.edgecloudmodel.eCModel.BooleanLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.CallMessage;
import org.xtext.example.edgecloudmodel.eCModel.ClassiferCallExpCS;
import org.xtext.example.edgecloudmodel.eCModel.CollectionItem;
import org.xtext.example.edgecloudmodel.eCModel.CollectionLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.CollectionRangeCS;
import org.xtext.example.edgecloudmodel.eCModel.CollectionTypeCS;
import org.xtext.example.edgecloudmodel.eCModel.CollectionTypeIdentifierCS;
import org.xtext.example.edgecloudmodel.eCModel.CombinedFragment;
import org.xtext.example.edgecloudmodel.eCModel.CombinedFragmentEnd;
import org.xtext.example.edgecloudmodel.eCModel.Contract;
import org.xtext.example.edgecloudmodel.eCModel.Definition;
import org.xtext.example.edgecloudmodel.eCModel.DomainModel;
import org.xtext.example.edgecloudmodel.eCModel.ECModelPackage;
import org.xtext.example.edgecloudmodel.eCModel.Entity;
import org.xtext.example.edgecloudmodel.eCModel.EntityAttributeName;
import org.xtext.example.edgecloudmodel.eCModel.EntityType;
import org.xtext.example.edgecloudmodel.eCModel.EnumEntity;
import org.xtext.example.edgecloudmodel.eCModel.EnumItem;
import org.xtext.example.edgecloudmodel.eCModel.EnumLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.Execution;
import org.xtext.example.edgecloudmodel.eCModel.ExecutionEnd;
import org.xtext.example.edgecloudmodel.eCModel.ForkNode;
import org.xtext.example.edgecloudmodel.eCModel.IfExpCS;
import org.xtext.example.edgecloudmodel.eCModel.InitalNode;
import org.xtext.example.edgecloudmodel.eCModel.Interaction;
import org.xtext.example.edgecloudmodel.eCModel.InvalidLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.Invariance;
import org.xtext.example.edgecloudmodel.eCModel.IteratorExpCS;
import org.xtext.example.edgecloudmodel.eCModel.JoinNode;
import org.xtext.example.edgecloudmodel.eCModel.LetExpCS;
import org.xtext.example.edgecloudmodel.eCModel.LogicFormulaExpCS;
import org.xtext.example.edgecloudmodel.eCModel.LoopExp;
import org.xtext.example.edgecloudmodel.eCModel.MessageEnd;
import org.xtext.example.edgecloudmodel.eCModel.NestedExpCS;
import org.xtext.example.edgecloudmodel.eCModel.NullLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.NumberLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.OclTypeCS;
import org.xtext.example.edgecloudmodel.eCModel.Operand;
import org.xtext.example.edgecloudmodel.eCModel.OperandEnd;
import org.xtext.example.edgecloudmodel.eCModel.Operation;
import org.xtext.example.edgecloudmodel.eCModel.OperationCallExpCS;
import org.xtext.example.edgecloudmodel.eCModel.OperationParameters;
import org.xtext.example.edgecloudmodel.eCModel.Partition;
import org.xtext.example.edgecloudmodel.eCModel.PartitionAction;
import org.xtext.example.edgecloudmodel.eCModel.Postcondition;
import org.xtext.example.edgecloudmodel.eCModel.Precondition;
import org.xtext.example.edgecloudmodel.eCModel.PrimitiveTypeCS;
import org.xtext.example.edgecloudmodel.eCModel.PropertyCallExpCS;
import org.xtext.example.edgecloudmodel.eCModel.Reference;
import org.xtext.example.edgecloudmodel.eCModel.RequirementModel;
import org.xtext.example.edgecloudmodel.eCModel.ReturnMessage;
import org.xtext.example.edgecloudmodel.eCModel.Service;
import org.xtext.example.edgecloudmodel.eCModel.SimpleOperation;
import org.xtext.example.edgecloudmodel.eCModel.StandardCollectionOperation;
import org.xtext.example.edgecloudmodel.eCModel.StandardDateOperation;
import org.xtext.example.edgecloudmodel.eCModel.StandardNavigationCallExpCS;
import org.xtext.example.edgecloudmodel.eCModel.StandardNoneParameterOperation;
import org.xtext.example.edgecloudmodel.eCModel.StandardOperationExpCS;
import org.xtext.example.edgecloudmodel.eCModel.StandardParameterOperation;
import org.xtext.example.edgecloudmodel.eCModel.StringLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.SwitchCase;
import org.xtext.example.edgecloudmodel.eCModel.SwitchDefault;
import org.xtext.example.edgecloudmodel.eCModel.SwitchExp;
import org.xtext.example.edgecloudmodel.eCModel.TupleLiteralExpCS;
import org.xtext.example.edgecloudmodel.eCModel.TupleTypeCS;
import org.xtext.example.edgecloudmodel.eCModel.UC;
import org.xtext.example.edgecloudmodel.eCModel.UseCaseModel;
import org.xtext.example.edgecloudmodel.eCModel.VariableDeclarationCS;
import org.xtext.example.edgecloudmodel.eCModel.VariableExpCS;
import org.xtext.example.edgecloudmodel.eCModel.Workflow;
import org.xtext.example.edgecloudmodel.services.ECModelGrammarAccess;

@SuppressWarnings("all")
public class ECModelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ECModelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ECModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ECModelPackage.ACTIVITY_FINAL:
				sequence_ActivityFinal(context, (ActivityFinal) semanticObject); 
				return; 
			case ECModelPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case ECModelPackage.ARGUMENTS_CS:
				sequence_ArgumentsCS(context, (ArgumentsCS) semanticObject); 
				return; 
			case ECModelPackage.ATOMIC_EXPRESSION:
				sequence_AtomicExpression(context, (AtomicExpression) semanticObject); 
				return; 
			case ECModelPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ECModelPackage.BOOLEAN_LITERAL_EXP_CS:
				sequence_BooleanLiteralExpCS(context, (BooleanLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.CALL_MESSAGE:
				sequence_CallMessage(context, (CallMessage) semanticObject); 
				return; 
			case ECModelPackage.CLASSIFER_CALL_EXP_CS:
				sequence_ClassiferCallExpCS(context, (ClassiferCallExpCS) semanticObject); 
				return; 
			case ECModelPackage.COLLECTION_ITEM:
				sequence_CollectionItem(context, (CollectionItem) semanticObject); 
				return; 
			case ECModelPackage.COLLECTION_LITERAL_EXP_CS:
				sequence_CollectionLiteralExpCS(context, (CollectionLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.COLLECTION_RANGE_CS:
				sequence_CollectionRangeCS(context, (CollectionRangeCS) semanticObject); 
				return; 
			case ECModelPackage.COLLECTION_TYPE_CS:
				sequence_CollectionTypeCS(context, (CollectionTypeCS) semanticObject); 
				return; 
			case ECModelPackage.COLLECTION_TYPE_IDENTIFIER_CS:
				sequence_CollectionTypeIdentifierCS(context, (CollectionTypeIdentifierCS) semanticObject); 
				return; 
			case ECModelPackage.COMBINED_FRAGMENT:
				sequence_CombinedFragment(context, (CombinedFragment) semanticObject); 
				return; 
			case ECModelPackage.COMBINED_FRAGMENT_END:
				sequence_CombinedFragmentEnd(context, (CombinedFragmentEnd) semanticObject); 
				return; 
			case ECModelPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case ECModelPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case ECModelPackage.DOMAIN_MODEL:
				sequence_DomainModel(context, (DomainModel) semanticObject); 
				return; 
			case ECModelPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case ECModelPackage.ENTITY_ATTRIBUTE_NAME:
				sequence_EntityAttributeName(context, (EntityAttributeName) semanticObject); 
				return; 
			case ECModelPackage.ENTITY_TYPE:
				sequence_EntityType(context, (EntityType) semanticObject); 
				return; 
			case ECModelPackage.ENUM_ENTITY:
				sequence_EnumEntity(context, (EnumEntity) semanticObject); 
				return; 
			case ECModelPackage.ENUM_ITEM:
				sequence_EnumItem(context, (EnumItem) semanticObject); 
				return; 
			case ECModelPackage.ENUM_LITERAL_EXP_CS:
				sequence_EnumLiteralExpCS(context, (EnumLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.EXECUTION:
				sequence_Execution(context, (Execution) semanticObject); 
				return; 
			case ECModelPackage.EXECUTION_END:
				sequence_ExecutionEnd(context, (ExecutionEnd) semanticObject); 
				return; 
			case ECModelPackage.FORK_NODE:
				sequence_ForkNode(context, (ForkNode) semanticObject); 
				return; 
			case ECModelPackage.IF_EXP_CS:
				sequence_IfExpCS(context, (IfExpCS) semanticObject); 
				return; 
			case ECModelPackage.INITAL_NODE:
				sequence_InitalNode(context, (InitalNode) semanticObject); 
				return; 
			case ECModelPackage.INTERACTION:
				sequence_Interaction(context, (Interaction) semanticObject); 
				return; 
			case ECModelPackage.INVALID_LITERAL_EXP_CS:
				sequence_InvalidLiteralExpCS(context, (InvalidLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.INVARIANCE:
				sequence_Invariance(context, (Invariance) semanticObject); 
				return; 
			case ECModelPackage.ITERATOR_EXP_CS:
				sequence_IteratorExpCS(context, (IteratorExpCS) semanticObject); 
				return; 
			case ECModelPackage.JOIN_NODE:
				sequence_JoinNode(context, (JoinNode) semanticObject); 
				return; 
			case ECModelPackage.LET_EXP_CS:
				sequence_LetExpCS(context, (LetExpCS) semanticObject); 
				return; 
			case ECModelPackage.LOGIC_FORMULA_EXP_CS:
				sequence_LogicFormulaExpCS(context, (LogicFormulaExpCS) semanticObject); 
				return; 
			case ECModelPackage.LOOP_EXP:
				sequence_LoopExp(context, (LoopExp) semanticObject); 
				return; 
			case ECModelPackage.MESSAGE_END:
				sequence_MessageEnd(context, (MessageEnd) semanticObject); 
				return; 
			case ECModelPackage.NESTED_EXP_CS:
				sequence_NestedExpCS(context, (NestedExpCS) semanticObject); 
				return; 
			case ECModelPackage.NULL_LITERAL_EXP_CS:
				sequence_NullLiteralExpCS(context, (NullLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.NUMBER_LITERAL_EXP_CS:
				sequence_NumberLiteralExpCS(context, (NumberLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.OCL_TYPE_CS:
				sequence_OclTypeCS(context, (OclTypeCS) semanticObject); 
				return; 
			case ECModelPackage.OPERAND:
				sequence_Operand(context, (Operand) semanticObject); 
				return; 
			case ECModelPackage.OPERAND_END:
				sequence_OperandEnd(context, (OperandEnd) semanticObject); 
				return; 
			case ECModelPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case ECModelPackage.OPERATION_CALL_EXP_CS:
				sequence_OperationCallExpCS(context, (OperationCallExpCS) semanticObject); 
				return; 
			case ECModelPackage.OPERATION_PARAMETERS:
				sequence_OperationParameters(context, (OperationParameters) semanticObject); 
				return; 
			case ECModelPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.example.edgecloudmodel.eCModel.Parameter) semanticObject); 
				return; 
			case ECModelPackage.PARTITION:
				sequence_Partition(context, (Partition) semanticObject); 
				return; 
			case ECModelPackage.PARTITION_ACTION:
				sequence_PartitionAction(context, (PartitionAction) semanticObject); 
				return; 
			case ECModelPackage.POSTCONDITION:
				sequence_Postcondition(context, (Postcondition) semanticObject); 
				return; 
			case ECModelPackage.PRECONDITION:
				sequence_Precondition(context, (Precondition) semanticObject); 
				return; 
			case ECModelPackage.PRIMITIVE_TYPE_CS:
				sequence_PrimitiveTypeCS(context, (PrimitiveTypeCS) semanticObject); 
				return; 
			case ECModelPackage.PROPERTY_CALL_EXP_CS:
				sequence_PropertyCallExpCS(context, (PropertyCallExpCS) semanticObject); 
				return; 
			case ECModelPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case ECModelPackage.REQUIREMENT_MODEL:
				sequence_RequirementModel(context, (RequirementModel) semanticObject); 
				return; 
			case ECModelPackage.RETURN_MESSAGE:
				sequence_ReturnMessage(context, (ReturnMessage) semanticObject); 
				return; 
			case ECModelPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case ECModelPackage.SIMPLE_OPERATION:
				sequence_SimpleOperation(context, (SimpleOperation) semanticObject); 
				return; 
			case ECModelPackage.STANDARD_COLLECTION_OPERATION:
				sequence_StandardCollectionOperation(context, (StandardCollectionOperation) semanticObject); 
				return; 
			case ECModelPackage.STANDARD_DATE_OPERATION:
				sequence_StandardDateOperation(context, (StandardDateOperation) semanticObject); 
				return; 
			case ECModelPackage.STANDARD_NAVIGATION_CALL_EXP_CS:
				sequence_StandardNavigationCallExpCS(context, (StandardNavigationCallExpCS) semanticObject); 
				return; 
			case ECModelPackage.STANDARD_NONE_PARAMETER_OPERATION:
				sequence_StandardNoneParameterOperation(context, (StandardNoneParameterOperation) semanticObject); 
				return; 
			case ECModelPackage.STANDARD_OPERATION_EXP_CS:
				sequence_StandardOperationExpCS(context, (StandardOperationExpCS) semanticObject); 
				return; 
			case ECModelPackage.STANDARD_PARAMETER_OPERATION:
				sequence_StandardParameterOperation(context, (StandardParameterOperation) semanticObject); 
				return; 
			case ECModelPackage.STRING_LITERAL_EXP_CS:
				sequence_StringLiteralExpCS(context, (StringLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.SWITCH_CASE:
				sequence_SwitchCase(context, (SwitchCase) semanticObject); 
				return; 
			case ECModelPackage.SWITCH_DEFAULT:
				sequence_SwitchDefault(context, (SwitchDefault) semanticObject); 
				return; 
			case ECModelPackage.SWITCH_EXP:
				sequence_SwitchExp(context, (SwitchExp) semanticObject); 
				return; 
			case ECModelPackage.TUPLE_LITERAL_EXP_CS:
				sequence_TupleLiteralExpCS(context, (TupleLiteralExpCS) semanticObject); 
				return; 
			case ECModelPackage.TUPLE_TYPE_CS:
				sequence_TupleTypeCS(context, (TupleTypeCS) semanticObject); 
				return; 
			case ECModelPackage.UC:
				sequence_UC(context, (UC) semanticObject); 
				return; 
			case ECModelPackage.USE_CASE_MODEL:
				sequence_UseCaseModel(context, (UseCaseModel) semanticObject); 
				return; 
			case ECModelPackage.VARIABLE_DECLARATION_CS:
				sequence_VariableDeclarationCS(context, (VariableDeclarationCS) semanticObject); 
				return; 
			case ECModelPackage.VARIABLE_EXP_CS:
				sequence_VariableExpCS(context, (VariableExpCS) semanticObject); 
				return; 
			case ECModelPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     WorkflowExp returns ActivityFinal
	 *     ActivityFinal returns ActivityFinal
	 *
	 * Constraint:
	 *     name='ActivityFinal'
	 */
	protected void sequence_ActivityFinal(ISerializationContext context, ActivityFinal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ACTIVITY_FINAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ACTIVITY_FINAL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActivityFinalAccess().getNameActivityFinalKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MultiEnd returns Actor
	 *     Actor returns Actor
	 *     Participant returns Actor
	 *
	 * Constraint:
	 *     (name=SimpleNameCS label=DOUBLE_QUOTED_STRING? superActor=[Actor|ID]? description=DOUBLE_QUOTED_STRING? uc+=[UC|ID]*)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentsCS returns ArgumentsCS
	 *
	 * Constraint:
	 *     (first=OCLExpressionCS next=ArgumentsCS?)
	 */
	protected void sequence_ArgumentsCS(ISerializationContext context, ArgumentsCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AtomicExpression returns AtomicExpression
	 *
	 * Constraint:
	 *     (
	 *         leftside=LeftSubAtomicExpression 
	 *         (infixop=InfixCompareOperatorName rightside=RightSubAtomicExpression (op=InfixOperatorName (num=PrimitiveLiteralExpCS | exp=AtomicExpression))?)?
	 *     )
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=SimpleNameCS type=TypeCS ismultiple?='*'?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns BooleanLiteralExpCS
	 *     RightSubAtomicExpression returns BooleanLiteralExpCS
	 *     LiteralExpCS returns BooleanLiteralExpCS
	 *     PrimitiveLiteralExpCS returns BooleanLiteralExpCS
	 *     BooleanLiteralExpCS returns BooleanLiteralExpCS
	 *
	 * Constraint:
	 *     (symbol='true' | symbol='false')
	 */
	protected void sequence_BooleanLiteralExpCS(ISerializationContext context, BooleanLiteralExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns CallMessage
	 *     CallMessage returns CallMessage
	 *
	 * Constraint:
	 *     (name=SimpleNameCS op=[Operation|ID] sendingEnd=[MixEnd|ID] receivingEnd=[MixEnd|ID])
	 */
	protected void sequence_CallMessage(ISerializationContext context, CallMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MESSAGE__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.CALL_MESSAGE__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.CALL_MESSAGE__OP));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MESSAGE__SENDING_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MESSAGE__SENDING_END));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MESSAGE__RECEIVING_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MESSAGE__RECEIVING_END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallMessageAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCallMessageAccess().getOpOperationIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.CALL_MESSAGE__OP, false));
		feeder.accept(grammarAccess.getCallMessageAccess().getSendingEndMixEndIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ECModelPackage.Literals.MESSAGE__SENDING_END, false));
		feeder.accept(grammarAccess.getCallMessageAccess().getReceivingEndMixEndIDTerminalRuleCall_6_0_1(), semanticObject.eGet(ECModelPackage.Literals.MESSAGE__RECEIVING_END, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LeftSubAtomicExpression returns ClassiferCallExpCS
	 *     RightSubAtomicExpression returns ClassiferCallExpCS
	 *     CallExpCS returns ClassiferCallExpCS
	 *     FeatureCallExpCS returns ClassiferCallExpCS
	 *     ClassiferCallExpCS returns ClassiferCallExpCS
	 *
	 * Constraint:
	 *     (entity=SimpleNameCS op='allInstance()')
	 */
	protected void sequence_ClassiferCallExpCS(ISerializationContext context, ClassiferCallExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.CLASSIFER_CALL_EXP_CS__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.CLASSIFER_CALL_EXP_CS__ENTITY));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.CLASSIFER_CALL_EXP_CS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.CLASSIFER_CALL_EXP_CS__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassiferCallExpCSAccess().getEntitySimpleNameCSParserRuleCall_0_0(), semanticObject.getEntity());
		feeder.accept(grammarAccess.getClassiferCallExpCSAccess().getOpAllInstanceKeyword_2_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CollectionLiteralPartCS returns CollectionItem
	 *     CollectionItem returns CollectionItem
	 *
	 * Constraint:
	 *     item=OCLExpressionCS
	 */
	protected void sequence_CollectionItem(ISerializationContext context, CollectionItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.COLLECTION_ITEM__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.COLLECTION_ITEM__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionItemAccess().getItemOCLExpressionCSParserRuleCall_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns CollectionLiteralExpCS
	 *     RightSubAtomicExpression returns CollectionLiteralExpCS
	 *     LiteralExpCS returns CollectionLiteralExpCS
	 *     CollectionLiteralExpCS returns CollectionLiteralExpCS
	 *
	 * Constraint:
	 *     (kind=CollectionTypeIdentifierCS part+=CollectionLiteralPartCS? part+=CollectionLiteralPartCS*)
	 */
	protected void sequence_CollectionLiteralExpCS(ISerializationContext context, CollectionLiteralExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionLiteralPartCS returns CollectionRangeCS
	 *     CollectionRangeCS returns CollectionRangeCS
	 *
	 * Constraint:
	 *     (first=OCLExpressionCS last=OCLExpressionCS)
	 */
	protected void sequence_CollectionRangeCS(ISerializationContext context, CollectionRangeCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.COLLECTION_RANGE_CS__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.COLLECTION_RANGE_CS__FIRST));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.COLLECTION_RANGE_CS__LAST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.COLLECTION_RANGE_CS__LAST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionRangeCSAccess().getFirstOCLExpressionCSParserRuleCall_0_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getCollectionRangeCSAccess().getLastOCLExpressionCSParserRuleCall_2_0(), semanticObject.getLast());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeCS returns CollectionTypeCS
	 *     CollectionTypeCS returns CollectionTypeCS
	 *
	 * Constraint:
	 *     (name=CollectionTypeIdentifierCS type=TypeCS)
	 */
	protected void sequence_CollectionTypeCS(ISerializationContext context, CollectionTypeCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.COLLECTION_TYPE_CS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.COLLECTION_TYPE_CS__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.COLLECTION_TYPE_CS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.COLLECTION_TYPE_CS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionTypeCSAccess().getNameCollectionTypeIdentifierCSParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCollectionTypeCSAccess().getTypeTypeCSParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReservedKeywordCS returns CollectionTypeIdentifierCS
	 *     CollectionTypeIdentifierCS returns CollectionTypeIdentifierCS
	 *
	 * Constraint:
	 *     (name='Set' | name='Bag' | name='Sequence' | name='Collection' | name='OrderedSet')
	 */
	protected void sequence_CollectionTypeIdentifierCS(ISerializationContext context, CollectionTypeIdentifierCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractEnd returns CombinedFragmentEnd
	 *     MixOpAndCFEnd returns CombinedFragmentEnd
	 *     CombinedFragmentEnd returns CombinedFragmentEnd
	 *
	 * Constraint:
	 *     (name=SimpleNameCS owner=[CombinedFragment|ID])
	 */
	protected void sequence_CombinedFragmentEnd(ISerializationContext context, CombinedFragmentEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.COMBINED_FRAGMENT_END__OWNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.COMBINED_FRAGMENT_END__OWNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCombinedFragmentEndAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCombinedFragmentEndAccess().getOwnerCombinedFragmentIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.COMBINED_FRAGMENT_END__OWNER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CombinedFragment returns CombinedFragment
	 *
	 * Constraint:
	 *     (
	 *         name=SimpleNameCS 
	 *         operator=Operator 
	 *         coveredParticipants+=[Participant|ID]* 
	 *         start=[CombinedFragmentEnd|ID] 
	 *         finish=[CombinedFragmentEnd|ID] 
	 *         ownedOperands+=Operand*
	 *     )
	 */
	protected void sequence_CombinedFragment(ISerializationContext context, CombinedFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (service=[Service|ID] op=Operation def=Definition? pre=Precondition post=Postcondition)
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (variable+=VariableDeclarationCS variable+=VariableDeclarationCS*)
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainModel returns DomainModel
	 *
	 * Constraint:
	 *     (name=SimpleNameCS label=DOUBLE_QUOTED_STRING? entity+=Entity*)
	 */
	protected void sequence_DomainModel(ISerializationContext context, DomainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityAttributeName returns EntityAttributeName
	 *
	 * Constraint:
	 *     name=SimpleNameCS
	 */
	protected void sequence_EntityAttributeName(ISerializationContext context, EntityAttributeName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ENTITY_ATTRIBUTE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ENTITY_ATTRIBUTE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityAttributeNameAccess().getNameSimpleNameCSParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeCS returns EntityType
	 *     EntityType returns EntityType
	 *
	 * Constraint:
	 *     entity=[Entity|ID]
	 */
	protected void sequence_EntityType(ISerializationContext context, EntityType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ENTITY_TYPE__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ENTITY_TYPE__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityTypeAccess().getEntityEntityIDTerminalRuleCall_0_1(), semanticObject.eGet(ECModelPackage.Literals.ENTITY_TYPE__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (
	 *         isCRUD?='@AutoCRUD'? 
	 *         name=SimpleNameCS 
	 *         superEntity=[Entity|ID]? 
	 *         description=DOUBLE_QUOTED_STRING? 
	 *         attributes+=Attribute* 
	 *         reference+=Reference* 
	 *         invariance+=Invariance*
	 *     )
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeCS returns EnumEntity
	 *     EnumEntity returns EnumEntity
	 *
	 * Constraint:
	 *     (name=SimpleNameCS element+=EnumItem element+=EnumItem*)
	 */
	protected void sequence_EnumEntity(ISerializationContext context, EnumEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumItem returns EnumItem
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumItem(ISerializationContext context, EnumItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ENUM_ITEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ENUM_ITEM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumItemAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns EnumLiteralExpCS
	 *     RightSubAtomicExpression returns EnumLiteralExpCS
	 *     LiteralExpCS returns EnumLiteralExpCS
	 *     EnumLiteralExpCS returns EnumLiteralExpCS
	 *
	 * Constraint:
	 *     (enumname=SimpleNameCS eunmitem=ID)
	 */
	protected void sequence_EnumLiteralExpCS(ISerializationContext context, EnumLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ENUM_LITERAL_EXP_CS__ENUMNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ENUM_LITERAL_EXP_CS__ENUMNAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ENUM_LITERAL_EXP_CS__EUNMITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ENUM_LITERAL_EXP_CS__EUNMITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralExpCSAccess().getEnumnameSimpleNameCSParserRuleCall_0_0(), semanticObject.getEnumname());
		feeder.accept(grammarAccess.getEnumLiteralExpCSAccess().getEunmitemIDTerminalRuleCall_2_0(), semanticObject.getEunmitem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractEnd returns ExecutionEnd
	 *     MixEnd returns ExecutionEnd
	 *     ExecutionEnd returns ExecutionEnd
	 *
	 * Constraint:
	 *     (name=SimpleNameCS context=[MultiEnd|ID] execution=[Execution|ID])
	 */
	protected void sequence_ExecutionEnd(ISerializationContext context, ExecutionEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MIX_END__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MIX_END__CONTEXT));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.EXECUTION_END__EXECUTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.EXECUTION_END__EXECUTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExecutionEndAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExecutionEndAccess().getContextMultiEndIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.MIX_END__CONTEXT, false));
		feeder.accept(grammarAccess.getExecutionEndAccess().getExecutionExecutionIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ECModelPackage.Literals.EXECUTION_END__EXECUTION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Execution returns Execution
	 *     MultiEnd returns Execution
	 *
	 * Constraint:
	 *     (name=SimpleNameCS owner=[Participant|ID] start=[ExecutionEnd|ID] end=[ExecutionEnd|ID])
	 */
	protected void sequence_Execution(ISerializationContext context, Execution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MULTI_END__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MULTI_END__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.EXECUTION__OWNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.EXECUTION__OWNER));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.EXECUTION__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.EXECUTION__START));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.EXECUTION__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.EXECUTION__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExecutionAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExecutionAccess().getOwnerParticipantIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.EXECUTION__OWNER, false));
		feeder.accept(grammarAccess.getExecutionAccess().getStartExecutionEndIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ECModelPackage.Literals.EXECUTION__START, false));
		feeder.accept(grammarAccess.getExecutionAccess().getEndExecutionEndIDTerminalRuleCall_5_0_1(), semanticObject.eGet(ECModelPackage.Literals.EXECUTION__END, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WorkflowExp returns ForkNode
	 *     ForkNode returns ForkNode
	 *
	 * Constraint:
	 *     startlinks+=[JoinExp|ID]+
	 */
	protected void sequence_ForkNode(ISerializationContext context, ForkNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns IfExpCS
	 *     IfExpCS returns IfExpCS
	 *
	 * Constraint:
	 *     (condition=OCLExpressionCS thenExpression=OCLExpressionCS elseExpression=OCLExpressionCS?)
	 */
	protected void sequence_IfExpCS(ISerializationContext context, IfExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkflowExp returns InitalNode
	 *     InitalNode returns InitalNode
	 *
	 * Constraint:
	 *     name='ActivityStart'
	 */
	protected void sequence_InitalNode(ISerializationContext context, InitalNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.INITAL_NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.INITAL_NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitalNodeAccess().getNameActivityStartKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Interaction returns Interaction
	 *
	 * Constraint:
	 *     (
	 *         name=SimpleNameCS 
	 *         participants+=[Participant|ID]* 
	 *         messages+=Message* 
	 *         executions+=Execution* 
	 *         combinedFragments+=CombinedFragment* 
	 *         ends+=AbstractEnd*
	 *     )
	 */
	protected void sequence_Interaction(ISerializationContext context, Interaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns InvalidLiteralExpCS
	 *     RightSubAtomicExpression returns InvalidLiteralExpCS
	 *     LiteralExpCS returns InvalidLiteralExpCS
	 *     PrimitiveLiteralExpCS returns InvalidLiteralExpCS
	 *     InvalidLiteralExpCS returns InvalidLiteralExpCS
	 *
	 * Constraint:
	 *     symbol='invalid'
	 */
	protected void sequence_InvalidLiteralExpCS(ISerializationContext context, InvalidLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.PRIMITIVE_LITERAL_EXP_CS__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.PRIMITIVE_LITERAL_EXP_CS__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvalidLiteralExpCSAccess().getSymbolInvalidKeyword_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Invariance returns Invariance
	 *
	 * Constraint:
	 *     (name=SimpleNameCS (ocl=OCLExpressionCS | ocl=OCLExpressionCS) isForAssociation?='ASSOCINV'?)
	 */
	protected void sequence_Invariance(ISerializationContext context, Invariance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftSubAtomicExpression returns IteratorExpCS
	 *     RightSubAtomicExpression returns IteratorExpCS
	 *     CallExpCS returns IteratorExpCS
	 *     LoopExpCS returns IteratorExpCS
	 *     IteratorExpCS returns IteratorExpCS
	 *
	 * Constraint:
	 *     (
	 *         (objectCall=ClassiferCallExpCS | objectCall=PropertyCallExpCS | simpleCall=SimpleNameCS) 
	 *         iterator=IteratorIdentifier 
	 *         (varibles+=VariableDeclarationCS varibles+=VariableDeclarationCS*)? 
	 *         (exp=LogicFormulaExpCS | exp=IfExpCS)
	 *     )
	 */
	protected void sequence_IteratorExpCS(ISerializationContext context, IteratorExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkflowExp returns JoinNode
	 *     JoinNode returns JoinNode
	 *
	 * Constraint:
	 *     endlinks+=[JoinExp|ID]+
	 */
	protected void sequence_JoinNode(ISerializationContext context, JoinNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns LetExpCS
	 *     LetExpCS returns LetExpCS
	 *
	 * Constraint:
	 *     (variable+=VariableDeclarationCS variable+=VariableDeclarationCS* inExpression=OCLExpressionCS)
	 */
	protected void sequence_LetExpCS(ISerializationContext context, LetExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns LogicFormulaExpCS
	 *     LogicFormulaExpCS returns LogicFormulaExpCS
	 *
	 * Constraint:
	 *     (
	 *         atomicexp+=AtomicExpression 
	 *         ((connector+='and' | connector+='or') (atomicexp+=AtomicExpression | atomicexp+=IfExpCS | atomicexp+=NestedExpCS))*
	 *     )
	 */
	protected void sequence_LogicFormulaExpCS(ISerializationContext context, LogicFormulaExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkflowExp returns LoopExp
	 *     JoinExp returns LoopExp
	 *     ComplexOpeartion returns LoopExp
	 *     LoopExp returns LoopExp
	 *
	 * Constraint:
	 *     (name=SimpleNameCS exps+=WorkflowExp*)
	 */
	protected void sequence_LoopExp(ISerializationContext context, LoopExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractEnd returns MessageEnd
	 *     MixEnd returns MessageEnd
	 *     MessageEnd returns MessageEnd
	 *
	 * Constraint:
	 *     (name=SimpleNameCS context=[MultiEnd|ID] message=[Message|ID])
	 */
	protected void sequence_MessageEnd(ISerializationContext context, MessageEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MIX_END__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MIX_END__CONTEXT));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MESSAGE_END__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MESSAGE_END__MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageEndAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMessageEndAccess().getContextMultiEndIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.MIX_END__CONTEXT, false));
		feeder.accept(grammarAccess.getMessageEndAccess().getMessageMessageIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ECModelPackage.Literals.MESSAGE_END__MESSAGE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns NestedExpCS
	 *     NestedExpCS returns NestedExpCS
	 *
	 * Constraint:
	 *     nestedExpression=OCLExpressionCS
	 */
	protected void sequence_NestedExpCS(ISerializationContext context, NestedExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.NESTED_EXP_CS__NESTED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.NESTED_EXP_CS__NESTED_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNestedExpCSAccess().getNestedExpressionOCLExpressionCSParserRuleCall_1_0(), semanticObject.getNestedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns NullLiteralExpCS
	 *     RightSubAtomicExpression returns NullLiteralExpCS
	 *     LiteralExpCS returns NullLiteralExpCS
	 *     PrimitiveLiteralExpCS returns NullLiteralExpCS
	 *     NullLiteralExpCS returns NullLiteralExpCS
	 *
	 * Constraint:
	 *     symbol='null'
	 */
	protected void sequence_NullLiteralExpCS(ISerializationContext context, NullLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.PRIMITIVE_LITERAL_EXP_CS__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.PRIMITIVE_LITERAL_EXP_CS__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullLiteralExpCSAccess().getSymbolNullKeyword_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns NumberLiteralExpCS
	 *     RightSubAtomicExpression returns NumberLiteralExpCS
	 *     LiteralExpCS returns NumberLiteralExpCS
	 *     PrimitiveLiteralExpCS returns NumberLiteralExpCS
	 *     NumberLiteralExpCS returns NumberLiteralExpCS
	 *
	 * Constraint:
	 *     (symbol=IntegerLiteralExpCS | symbol=RealLiteralExpCS | symbol=UnlimitedNaturalLiteralExpCS)
	 */
	protected void sequence_NumberLiteralExpCS(ISerializationContext context, NumberLiteralExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReservedKeywordCS returns OclTypeCS
	 *     OclTypeCS returns OclTypeCS
	 *
	 * Constraint:
	 *     (name='OclAny' | name='OclInvalid' | name='OclVoid')
	 */
	protected void sequence_OclTypeCS(ISerializationContext context, OclTypeCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractEnd returns OperandEnd
	 *     MixOpAndCFEnd returns OperandEnd
	 *     OperandEnd returns OperandEnd
	 *
	 * Constraint:
	 *     (name=SimpleNameCS owner=[Operand|ID])
	 */
	protected void sequence_OperandEnd(ISerializationContext context, OperandEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.ABSTRACT_END__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.OPERAND_END__OWNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.OPERAND_END__OWNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperandEndAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOperandEndAccess().getOwnerOperandIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.OPERAND_END__OWNER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Operand
	 *
	 * Constraint:
	 *     (name=SimpleNameCS start=[OperandEnd|ID] finish=[MixOpAndCFEnd|ID])
	 */
	protected void sequence_Operand(ISerializationContext context, Operand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.OPERAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.OPERAND__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.OPERAND__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.OPERAND__START));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.OPERAND__FINISH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.OPERAND__FINISH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperandAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOperandAccess().getStartOperandEndIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.OPERAND__START, false));
		feeder.accept(grammarAccess.getOperandAccess().getFinishMixOpAndCFEndIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ECModelPackage.Literals.OPERAND__FINISH, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LeftSubAtomicExpression returns OperationCallExpCS
	 *     RightSubAtomicExpression returns OperationCallExpCS
	 *     CallExpCS returns OperationCallExpCS
	 *     FeatureCallExpCS returns OperationCallExpCS
	 *     OperationCallExpCS returns OperationCallExpCS
	 *
	 * Constraint:
	 *     (name=SimpleNameCS parameters+=OperationParameters? parameters+=OperationParameters*)
	 */
	protected void sequence_OperationCallExpCS(ISerializationContext context, OperationCallExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationParameters returns OperationParameters
	 *
	 * Constraint:
	 *     (object=SimpleNameCS | objectproperty=PropertyCallExpCS | string=SINGLE_QUOTED_STRING | string=DOUBLE_QUOTED_STRING)
	 */
	protected void sequence_OperationParameters(ISerializationContext context, OperationParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JoinExp returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (name=OperationName parameter+=Parameter? parameter+=Parameter* returnType=TypeCS?)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ParametersName type=TypeCS?)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.example.edgecloudmodel.eCModel.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkflowExp returns PartitionAction
	 *     PartitionAction returns PartitionAction
	 *
	 * Constraint:
	 *     (patition=[Participant|ID] action=[JoinExp|ID])
	 */
	protected void sequence_PartitionAction(ISerializationContext context, PartitionAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.PARTITION_ACTION__PATITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.PARTITION_ACTION__PATITION));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.PARTITION_ACTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.PARTITION_ACTION__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPartitionActionAccess().getPatitionParticipantIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ECModelPackage.Literals.PARTITION_ACTION__PATITION, false));
		feeder.accept(grammarAccess.getPartitionActionAccess().getActionJoinExpIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.PARTITION_ACTION__ACTION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Partition returns Partition
	 *
	 * Constraint:
	 *     (name=[Participant|ID] exps+=WorkflowExp*)
	 */
	protected void sequence_Partition(ISerializationContext context, Partition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Postcondition returns Postcondition
	 *
	 * Constraint:
	 *     (oclexp=OCLExpressionCS | oclexp=OCLExpressionCS)
	 */
	protected void sequence_Postcondition(ISerializationContext context, Postcondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Precondition returns Precondition
	 *
	 * Constraint:
	 *     (oclexp=OCLExpressionCS | oclexp=OCLExpressionCS)
	 */
	protected void sequence_Precondition(ISerializationContext context, Precondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeCS returns PrimitiveTypeCS
	 *     ReservedKeywordCS returns PrimitiveTypeCS
	 *     PrimitiveTypeCS returns PrimitiveTypeCS
	 *
	 * Constraint:
	 *     (
	 *         name='Boolean' | 
	 *         name='Integer' | 
	 *         name='Real' | 
	 *         name='String' | 
	 *         name='UnlimitedNatural' | 
	 *         name='Date'
	 *     )
	 */
	protected void sequence_PrimitiveTypeCS(ISerializationContext context, PrimitiveTypeCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftSubAtomicExpression returns PropertyCallExpCS
	 *     RightSubAtomicExpression returns PropertyCallExpCS
	 *     CallExpCS returns PropertyCallExpCS
	 *     FeatureCallExpCS returns PropertyCallExpCS
	 *     PropertyCallExpCS returns PropertyCallExpCS
	 *
	 * Constraint:
	 *     (name=VariableExpCS selfproperty=VariableExpCS? attribute=SimpleNameCS premark=IsMarkedPreCS?)
	 */
	protected void sequence_PropertyCallExpCS(ISerializationContext context, PropertyCallExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (
	 *         name=SimpleNameCS 
	 *         entity=[Entity|ID] 
	 *         ismultiple?='*'? 
	 *         isReverseAssoication?='!'? 
	 *         isAggregation?='@-'? 
	 *         isComposition?='*-'? 
	 *         type=AssociationTypeCS
	 *     )
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementModel returns RequirementModel
	 *
	 * Constraint:
	 *     (name=SimpleNameCS? description=DOUBLE_QUOTED_STRING? UseCaseModel=UseCaseModel DomainModel=DomainModel)
	 */
	protected void sequence_RequirementModel(ISerializationContext context, RequirementModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns ReturnMessage
	 *     ReturnMessage returns ReturnMessage
	 *
	 * Constraint:
	 *     (name=SimpleNameCS sendingEnd=[MixEnd|ID] receivingEnd=[MixEnd|ID] invocationMessage=[Message|ID])
	 */
	protected void sequence_ReturnMessage(ISerializationContext context, ReturnMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MESSAGE__NAME));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MESSAGE__SENDING_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MESSAGE__SENDING_END));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.MESSAGE__RECEIVING_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.MESSAGE__RECEIVING_END));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.RETURN_MESSAGE__INVOCATION_MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.RETURN_MESSAGE__INVOCATION_MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnMessageAccess().getNameSimpleNameCSParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReturnMessageAccess().getSendingEndMixEndIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ECModelPackage.Literals.MESSAGE__SENDING_END, false));
		feeder.accept(grammarAccess.getReturnMessageAccess().getReceivingEndMixEndIDTerminalRuleCall_5_0_1(), semanticObject.eGet(ECModelPackage.Literals.MESSAGE__RECEIVING_END, false));
		feeder.accept(grammarAccess.getReturnMessageAccess().getInvocationMessageMessageIDTerminalRuleCall_6_0_1(), semanticObject.eGet(ECModelPackage.Literals.RETURN_MESSAGE__INVOCATION_MESSAGE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MultiEnd returns Service
	 *     Service returns Service
	 *     Participant returns Service
	 *
	 * Constraint:
	 *     (
	 *         name=SimpleNameCS 
	 *         description=DOUBLE_QUOTED_STRING? 
	 *         operation+=Operation* 
	 *         temp_property+=Attribute* 
	 *         workflow+=[Workflow|ID]* 
	 *         invariance+=Invariance*
	 *     )
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkflowExp returns SimpleOperation
	 *     SimpleOperation returns SimpleOperation
	 *
	 * Constraint:
	 *     ref=[Operation|ID]
	 */
	protected void sequence_SimpleOperation(ISerializationContext context, SimpleOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.SIMPLE_OPERATION__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.SIMPLE_OPERATION__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleOperationAccess().getRefOperationIDTerminalRuleCall_0_1(), semanticObject.eGet(ECModelPackage.Literals.SIMPLE_OPERATION__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StandardCollectionOperation returns StandardCollectionOperation
	 *
	 * Constraint:
	 *     ((name='includes' | name='excludes' | name='includesAll' | name='excludesAll') object=SimpleNameCS)
	 */
	protected void sequence_StandardCollectionOperation(ISerializationContext context, StandardCollectionOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredefineOp returns StandardDateOperation
	 *     StandardDateOperation returns StandardDateOperation
	 *
	 * Constraint:
	 *     (
	 *         (name='After' | name='Before' | name='isAfter' | name='isBefore' | name='isEqual') 
	 *         (object=SimpleNameCS | datenum=NumberLiteralExpCS | procall=PropertyCallExpCS) 
	 *         nested=StandardDateOperation?
	 *     )
	 */
	protected void sequence_StandardDateOperation(ISerializationContext context, StandardDateOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftSubAtomicExpression returns StandardNavigationCallExpCS
	 *     RightSubAtomicExpression returns StandardNavigationCallExpCS
	 *     CallExpCS returns StandardNavigationCallExpCS
	 *     FeatureCallExpCS returns StandardNavigationCallExpCS
	 *     StandardNavigationCallExpCS returns StandardNavigationCallExpCS
	 *
	 * Constraint:
	 *     ((classifercall=ClassiferCallExpCS | propertycall=PropertyCallExpCS | object=SimpleNameCS) navop='->' standardOP=StandardCollectionOperation)
	 */
	protected void sequence_StandardNavigationCallExpCS(ISerializationContext context, StandardNavigationCallExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredefineOp returns StandardNoneParameterOperation
	 *     StandardNoneParameterOperation returns StandardNoneParameterOperation
	 *
	 * Constraint:
	 *     (
	 *         name='oclIsNew()' | 
	 *         name='oclIsUndefined()' | 
	 *         name='isEmpty()' | 
	 *         name='notEmpty()' | 
	 *         name='oclIsInvaild()' | 
	 *         name='size()' | 
	 *         name='sum()'
	 *     )
	 */
	protected void sequence_StandardNoneParameterOperation(ISerializationContext context, StandardNoneParameterOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftSubAtomicExpression returns StandardOperationExpCS
	 *     RightSubAtomicExpression returns StandardOperationExpCS
	 *     CallExpCS returns StandardOperationExpCS
	 *     FeatureCallExpCS returns StandardOperationExpCS
	 *     StandardOperationExpCS returns StandardOperationExpCS
	 *
	 * Constraint:
	 *     (object=VariableExpCS (property=VariableExpCS premark=IsMarkedPreCS?)? predefinedop=PredefineOp)
	 */
	protected void sequence_StandardOperationExpCS(ISerializationContext context, StandardOperationExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredefineOp returns StandardParameterOperation
	 *     StandardParameterOperation returns StandardParameterOperation
	 *
	 * Constraint:
	 *     (name='oclIsTypeOf' (type=PrimitiveTypeCS | type=EntityType))
	 */
	protected void sequence_StandardParameterOperation(ISerializationContext context, StandardParameterOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns StringLiteralExpCS
	 *     RightSubAtomicExpression returns StringLiteralExpCS
	 *     LiteralExpCS returns StringLiteralExpCS
	 *     PrimitiveLiteralExpCS returns StringLiteralExpCS
	 *     StringLiteralExpCS returns StringLiteralExpCS
	 *
	 * Constraint:
	 *     (symbol=SINGLE_QUOTED_STRING | symbol=DOUBLE_QUOTED_STRING)
	 */
	protected void sequence_StringLiteralExpCS(ISerializationContext context, StringLiteralExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchCase returns SwitchCase
	 *
	 * Constraint:
	 *     (caseValue=SimpleNameCS op=SimpleOperation)
	 */
	protected void sequence_SwitchCase(ISerializationContext context, SwitchCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.SWITCH_CASE__CASE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.SWITCH_CASE__CASE_VALUE));
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.SWITCH_CASE__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.SWITCH_CASE__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchCaseAccess().getCaseValueSimpleNameCSParserRuleCall_1_0(), semanticObject.getCaseValue());
		feeder.accept(grammarAccess.getSwitchCaseAccess().getOpSimpleOperationParserRuleCall_3_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchDefault returns SwitchDefault
	 *
	 * Constraint:
	 *     op=SimpleOperation
	 */
	protected void sequence_SwitchDefault(ISerializationContext context, SwitchDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ECModelPackage.Literals.SWITCH_DEFAULT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECModelPackage.Literals.SWITCH_DEFAULT__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchDefaultAccess().getOpSimpleOperationParserRuleCall_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WorkflowExp returns SwitchExp
	 *     JoinExp returns SwitchExp
	 *     ComplexOpeartion returns SwitchExp
	 *     SwitchExp returns SwitchExp
	 *
	 * Constraint:
	 *     (name=SimpleNameCS cases+=SwitchCase* default=SwitchDefault?)
	 */
	protected void sequence_SwitchExp(ISerializationContext context, SwitchExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCLExpressionCS returns TupleLiteralExpCS
	 *     RightSubAtomicExpression returns TupleLiteralExpCS
	 *     LiteralExpCS returns TupleLiteralExpCS
	 *     TupleLiteralExpCS returns TupleLiteralExpCS
	 *
	 * Constraint:
	 *     (name='Tuple' variables+=VariableDeclarationCS? variables+=VariableDeclarationCS*)
	 */
	protected void sequence_TupleLiteralExpCS(ISerializationContext context, TupleLiteralExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TupleTypeCS returns TupleTypeCS
	 *
	 * Constraint:
	 *     (name='Tuple' variables+=VariableDeclarationCS? variables+=VariableDeclarationCS*)
	 */
	protected void sequence_TupleTypeCS(ISerializationContext context, TupleTypeCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UC returns UC
	 *
	 * Constraint:
	 *     (
	 *         name=SimpleNameCS 
	 *         label=DOUBLE_QUOTED_STRING? 
	 *         (UCRelation=USECASE_RELATION relateduc+=[UC|ID] relateduc+=[UC|ID]*)? 
	 *         (ssd+=[Interaction|ID] ssd+=[Interaction|ID]*)? 
	 *         (service+=[Service|ID] service+=[Service|ID]*)? 
	 *         description=DOUBLE_QUOTED_STRING?
	 *     )
	 */
	protected void sequence_UC(ISerializationContext context, UC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseCaseModel returns UseCaseModel
	 *
	 * Constraint:
	 *     (
	 *         name=SimpleNameCS 
	 *         label=DOUBLE_QUOTED_STRING? 
	 *         uc+=UC* 
	 *         actor+=Actor* 
	 *         interaction+=Interaction* 
	 *         service+=Service* 
	 *         contract+=Contract*
	 *     )
	 */
	protected void sequence_UseCaseModel(ISerializationContext context, UseCaseModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationCS returns VariableDeclarationCS
	 *
	 * Constraint:
	 *     (name=SimpleNameCS type=TypeCS? initExpression=OCLExpressionCS?)
	 */
	protected void sequence_VariableDeclarationCS(ISerializationContext context, VariableDeclarationCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftSubAtomicExpression returns VariableExpCS
	 *     RightSubAtomicExpression returns VariableExpCS
	 *     VariableExpCS returns VariableExpCS
	 *
	 * Constraint:
	 *     (symbol='self' | symbol='result' | symbol=SimpleNameCS)
	 */
	protected void sequence_VariableExpCS(ISerializationContext context, VariableExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (name=SimpleNameCS participants+=[Participant|ID]* partitions+=Partition*)
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
